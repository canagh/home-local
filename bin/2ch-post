#!/usr/bin/python2
#-*- coding:utf-8 -*-

# my 3rd 2ch util in py
# 1st and 2nd is ugly to install because of the dependence

# based on twopy (MIT License)
# thanks to rezoo <http://mglab.blogspot.com/>
# $ svn checkout http://svn.coderepos.org/share/lang/python/twopy/trunk

import urllib
import urllib2
import cookielib
import string
import re
import time
import os
import subprocess

def autopost(target, res, user):
    r = post(target, res, user)
    return (post(target, res, user, hidden=r[2])
            if r[0] == 'cookie' else r)

def post(target, res, user, hidden={}):
    referer = urlconv('readcgi', target)
    [host, board, thread] = string.split(urlconv('tsv', target), "\t")
    send_dict = \
        { 'bbs': board
        , 'key': thread
        , 'time': int(time.time()) - 5 # delay
        , 'FROM': res['name'].encode('Shift_JIS')
        , 'mail': res['mail'].encode('Shift_JIS')
        , 'MESSAGE': res['message'].encode('Shift_JIS')
        , 'submit': u'書き込む'.encode('Shift_JIS')
        }
    send_dict.update(hidden)
    params = urllib.urlencode(send_dict)

    return bbs_post(target, params, referer, user)

def urlconv(typ, *args):
    return subprocess.check_output(['2ch-urlconv', typ] + list(args))

def bbs_post(target, params, referer, user):
    url = urlconv('bbscgi', target)
    try:
        response = urlpost(url, params, referer, user)
        if response.code == 200:
            body = unicode(response.read(), 'Shift_JIS', 'ignore')
            code = detect_status_code(body)
            if code == 'cookie':
                r = re.compile(r'input type=hidden name="(.+?)" value="(.+?)"').search(body)
                d = {r.group(1): r.group(2)}
                return (code, body, d)
            else:
                return (code, body)
        else:
            print unicode(response.read(), 'Shift_JIS', 'ignore')
            raise TypeError
    except urllib2.HTTPError, e:
        print e.code

def detect_status_code(body):
    for (regex, code) in \
            [ (re.compile(u'2ch_X,false'), 'false')
            , (re.compile(u'(2ch_X,true|書きこみました)'), 'true')
            , (re.compile(u'(2ch_X,error|ＥＲＲＯＲ)'), 'error')
            , (re.compile(u'2ch_X,check'), 'check')
            , (re.compile(u'(2ch_X,cookie|書き込み確認)'), 'cookie')
            ]:
        if regex.search(body):
            return code
    print body
    raise ValueError("can't detect the status code")

def urlpost(url, param, referer, user, language='ja', keep_alive=300):
    headers = {
        'User-Agent': user['user_agent'],
        'Accept': '*/*',
        'Accept-Language': language,
        'Keep-Alive': str(keep_alive),
        'Referer': referer,
        'Connection': 'close',
    }
    req = urllib2.Request(url, None, headers)
    user['cookie'].add_cookie_header(req)
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(user['cookie']))
    return opener.open(req, param)


import argparse

ch2dir=os.environ.get('CH2_DIR', os.environ['HOME'] + '/.2ch')
parser = argparse.ArgumentParser(description='Post messages to 2ch.net.')
parser.add_argument('-t', '--to', metavar='IDENTIFIER',
        help='The IDENTIFIER of a thread you want to post to.')
parser.add_argument('-n', '--name', metavar='STRING', default='',
        help='The default is "".')
parser.add_argument('-M', '--mail', metavar='ADDRESS', default='sage',
        help='The default is "sage".')
parser.add_argument('-m', '--message', metavar='TEXT', default='',
        help='If empty or not given, $EDITOR is opened to make a message')
parser.add_argument('--user-agent', metavar='STRING', default='Monazilla 1.00')
parser.add_argument('-c', '--cookie', metavar='PATH', default=ch2dir + '/cookie')
parser.add_argument('-f', '--force', action='store_true',
        help='Post without any confirmings.')
parser.add_argument('-p', '--print-body', action='store_true',
        help='Print the responce.')
parser.add_argument('--cookielib-cookie-type', metavar='TYPE', default='mozilla')
args = parser.parse_args()
if args.message == '':
    import tempfile
    with tempfile.NamedTemporaryFile() as tmp:
        subprocess.call([os.environ['EDITOR'], tmp.name])
        args.message = tmp.read().rsplit("\n", 1)[0]
if args.to is None:
    raise ValueError('the target is empty.')
try:
    urlconv('tsv', args.to)
except subprocess.CalledProcessError:
    raise

if not os.path.isdir(ch2dir):
    os.makedirs(ch2dir)
res = {'name': args.name, 'mail': args.mail, 'message': args.message}
for key in res:
    res[key] = res[key].decode('utf_8')
user = { 'user_agent': args.user_agent , 'cookie': {'mozilla': cookielib.MozillaCookieJar , 'lwp': cookielib.LWPCookieJar}[args.cookielib_cookie_type](args.cookie) }
if os.path.isfile(user['cookie'].filename):
    user['cookie'].load()
result = (autopost if args.force else post)(args.to, res, user)
user['cookie'].save()

if args.print_body or not result[0] == 'true':
    print result[1]
