#!/usr/bin/perl
use warnings;
use strict;
use feature 'switch';
use feature 'say';

use File::Basename;
use Getopt::Long;

use constant {
    THREAD      => 'thread',
    BOARD       => 'board',
    HOST        => 'host',

    DAT         => 'dat',
    SUBJECT     => 'subject',
    READCGI     => 'readcgi',
    BBSCGI      => 'bbscgi',
    BOARD_INDEX => 'board_index',
    TSV         => 'tsv',

    TYPE        => 'type',
    FORCE       => 'force',
};

sub parse() {
    my %attr = (HOST => '', BOARD => '', THREAD => '');
    my $string = $_[0];

    given ($string) {
        when (/^h?ttps?:\/\/([\w.]+)\/?$/) {
            $attr{HOST} = $1;
        }
        when (/^h?ttps?:\/\/([\w.]+)\/(\w+)\/?$/) {
            ($attr{HOST}, $attr{BOARD}) = ($1, $2);
        }
        when (/^(\w+)\W+(\d+)$/) {
            ($attr{BOARD}, $attr{THREAD}) = ($1, $2);
        }
        when (/^([\w.]+)\W+(\w+)\W*$/) {
            ($attr{HOST}, $attr{BOARD}) = ($1, $2);
        }
        when (/^([\w.]+)\W+(\w+)\W+(\d+)$/) {
            ($attr{HOST}, $attr{BOARD}, $attr{THREAD}) = ($1, $2, $3);
        }
        when (/\/read\.cgi\//) {
            ($attr{HOST}, $attr{BOARD}, $attr{THREAD}) = (split '/', $string)[2,5,6];
        }
        when (/\/dat\//) {
            ($attr{HOST}, $attr{BOARD}, $attr{THREAD}) = (split '/', $string)[2,3,5];
            $attr{THREAD} =~ s/\..*$/''/;
        }
        when (/\/subject.txt$/) {
            ($attr{HOST}, $attr{BOARD}) = (split '/', $string)[2,3];
        }
        when (/^\w+$/) {
            $attr{BOARD} = $string;
        }
        default {
            die basename $0 . ": couldn't parse";
        }
    }

    return %attr;
}

sub convert() {
    my %args = @_;
    my $error = sub { die basename $0 . ": couldn't convert: lack of infomation" unless $args{FORCE}; };

    given ($args{TYPE}) {
        when (DAT) {
            $error->() unless $args{THREAD};
            return &convert(%args, TYPE => BOARD_INDEX) . 'dat/' . $args{THREAD} . '.dat';
        }
        when (READCGI) {
            $error->() unless $args{HOST} and $args{BOARD} and $args{THREAD};
            return 'http://' . $args{HOST} . '/test/read.cgi/' . $args{BOARD} . '/' . $args{THREAD} . '/';
        }
        when (BBSCGI) {
            $error->() unless $args{HOST};
            return 'http://' . $args{HOST} . '/test/bbs.cgi';
        }
        when (TSV) {
            $error->() unless $args{HOST} and $args{BOARD} and $args{THREAD};
            return join "\t", ($args{HOST}, $args{BOARD}, $args{THREAD});
        }
        when (BOARD_INDEX) {
            $error->() unless $args{HOST} and $args{BOARD};
            return 'http://' . $args{HOST} . '/' . $args{BOARD} . '/';
        }
        when (SUBJECT) {
            return &convert(%args, TYPE => BOARD_INDEX) . 'subject.txt';
        }
        when (HOST) {
            $error->() unless $args{HOST};
            return $args{HOST};
        }
        when (BOARD) {
            $error->() unless $args{BOARD};
            return $args{BOARD};
        }
        when (THREAD) {
            $error->() unless $args{THREAD};
            return $args{THREAD};
        }
        default {
            die basename $0 . ': wrong type: ' . $args{TYPE};
        }
    }
}

sub solve() {
    my %args = @_[0..5];
    my @hosts = @_[6..$#_];

    unless ($args{HOST}) {
        foreach (@hosts) {
            open FH, $_;
            while (<FH>) {
                chomp $_;
                my ($board, $host) = split "\t", $_;
                if ($args{BOARD} eq $board) {
                    $args{HOST} = $host;
                    @hosts = ();
                    last;
                }
            }
            close FH;
        }
    }
    return %args;
}


my $force;
my @hosts = (($ENV{'CH2_DIR'} or $ENV{'HOME'} . '/.2ch') . '/hosts');
die 'Usage: ' . basename $0 . " TYPE [URL]\n"
    unless GetOptions(
        'f|force' => \$force,
        'H|hosts=s@' => \@hosts,
    );

my $type = shift;

my $url = join "\t", @ARGV;
if ($url) {
    say &convert(&solve(&parse($url), @hosts), TYPE => $type, FORCE => $force);
} else {
    while (<>) {
        say &convert(&solve(&parse($_), @hosts), TYPE => $type, FORCE => $force);
    }
}
