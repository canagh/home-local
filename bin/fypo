#!/usr/bin/perl
use strict;
use warnings;

use feature 'switch';

use Getopt::Long;
use File::Basename;
my @excludes = ();
my $minimum = 4;
my $distance = 'normalized-levenshtein';
my $minimum_ratio = 4;
my $sensitivity = 0.3;
my $use_look;
my $no_header;
die 'Usage: ' . basename $0 . " FILE..\n"
    . "Help to find typos from source code.\n"
    . "Error messages of some language (e.g. c++) are too complicated, even if the cause is only a typo!"
    unless GetOptions(
        'excludes=s@' => \@excludes,
        'minimum=i' => \$minimum,
        'distance' => \$distance,
        'minimum_ratio=i' => \$minimum_ratio,
        'sensitivity=f' => \$sensitivity,
        'use-look' => \$use_look,
        'no-header' => \$no_header,
    ) and @ARGV;

sub comparer() {
    given ($distance) {
        when ('levenshtein') {
            use Text::LevenshteinXS;
            my $var = $_[0];
            return sub { Text::LevenshteinXS::distance($var, $_[0]); }
        }
        when ('normalized-levenshtein') {
            use Text::LevenshteinXS;
            use List::Util qw(max);
            my $var = $_[0];
            return sub { Text::LevenshteinXS::distance($var, $_[0]) / (max (length $var, length $_[0])); }
        }
        default {
            die basename $0 . ': non-supported distance: ' . $distance . "\n";
        }
    }
}

sub split_words() {
    my $word = $_[0];
    $word =~ s/([[:upper:]])/_$1/g;
    my @words = split '_', $word;
    @words = map {lc $_} (grep {2 <= length $_} @words);
    return @words;
}

sub look() {
    my $word = $_[0];
    my @words = &split_words($word);
    foreach $word (@words) {
        return 0 unless `look -- "$word"` =~ /\b$word\b/;
    }
    return 1;
}


my %counts = ();

my $file;
foreach $file (@ARGV) {
    open FH, $file;
    while (<FH>) {
        my @words = grep /^\w+$/, (split /\b/, $_);
        my $word;
        foreach $word (grep {$minimum <= length $_} @words) {
            ++$counts{$word};
        }
    }
    close FH;
}

my @asc_words = sort {$counts{$a} cmp $counts{$b}} keys %counts;
my @desc_words = reverse @asc_words;
my $max_count = $counts{$desc_words[0]};

printf "%16s %16s %8s %16s\n", 'actual word', 'similar word', 'score', 'description' unless $no_header;
foreach (@asc_words) {
    my $word = $_;
    my $count = $counts{$word};
    my $cmp;
    next if grep {$_ eq $word} @excludes;
    last unless $minimum_ratio < $max_count / $count;
    foreach (@desc_words) {
        my $other = $_;
        my $ratio = $counts{$other} / $count;
        last unless $minimum_ratio < $ratio;
        $cmp = &comparer($word) unless $cmp;
        my $dist = $cmp->($other);
        if ($dist <= $sensitivity) {
            my $found_look = ($use_look and &look($word));
            my $score = 0.0;
            $score += 1.0 / $dist;
            $score += sqrt $ratio;
            $score += 4.0 / $count ** 2;
            $score += 6.0 if ($use_look and not $found_look);
            if (10.0 < $score) {
                printf '%16s %16s', $word, $other;
                printf ' %8.4f', $score;
                printf ' (distance %8.4f)', $dist;
                printf ' (frequency ratio %8.4f)', $ratio;
                print ' (only once appeared)' if ($count == 1);
                print ' (not found by look(1))' if ($use_look and not $found_look);
                print "\n";
            }
        }
    }
}
